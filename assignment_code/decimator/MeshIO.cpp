#include "MeshIO.hpp"
#include "gloo/MeshLoader.hpp"
#include <fstream>
#include <sstream>
#include <iostream>

namespace GLOO {

std::shared_ptr<SimplificationMesh> MeshIO::LoadOBJ(const std::string& filepath) {
  // TODO: Implement OBJ file loading
  // Parse vertex positions, normals, texture coordinates, and faces
  
  auto mesh = std::make_shared<SimplificationMesh>();
  std::ifstream file(filepath);
  
  if (!file.is_open()) {
    std::cerr << "Failed to open OBJ file: " << filepath << std::endl;
    return nullptr;
  }
  
  std::string line;
  while (std::getline(file, line)) {
    if (line.empty() || line[0] == '#') continue;
    
    std::istringstream iss(line);
    std::string prefix;
    iss >> prefix;
    
    if (prefix == "v") {
      // Vertex position
      glm::vec3 vertex;
      if (ParseVertex(line, vertex)) {
        mesh->vertices.push_back(vertex);
      }
    } else if (prefix == "vn") {
      // Vertex normal
      glm::vec3 normal;
      if (ParseNormal(line, normal)) {
        mesh->normals.push_back(normal);
      }
    } else if (prefix == "vt") {
      // Texture coordinate
      glm::vec2 texcoord;
      if (ParseTexCoord(line, texcoord)) {
        mesh->texcoords.push_back(texcoord);
      }
    } else if (prefix == "f") {
      // Face (TODO: handle complex face formats)
      std::vector<glm::uvec3> face_indices;
      if (ParseFace(line, face_indices)) {
        for (const auto& face : face_indices) {
          mesh->faces.push_back(face);
        }
      }
    }
  }
  
  file.close();
  
  // Compute normals if not provided
  if (mesh->normals.empty()) {
    mesh->ComputeNormals();
  }
  
  return mesh;
}

bool MeshIO::SaveOBJ(const std::string& filepath, const SimplificationMesh& mesh) {
  // TODO: Implement OBJ file saving
  std::ofstream file(filepath);
  
  if (!file.is_open()) {
    std::cerr << "Failed to open file for writing: " << filepath << std::endl;
    return false;
  }
  
  // Write header
  file << "# OBJ file generated by Decimator\n";
  file << "# Vertices: " << mesh.vertices.size() << "\n";
  file << "# Faces: " << mesh.faces.size() << "\n\n";
  
  // Write vertices
  for (const auto& v : mesh.vertices) {
    file << "v " << v.x << " " << v.y << " " << v.z << "\n";
  }
  
  // Write normals
  if (!mesh.normals.empty()) {
    file << "\n";
    for (const auto& n : mesh.normals) {
      file << "vn " << n.x << " " << n.y << " " << n.z << "\n";
    }
  }
  
  // Write texture coordinates
  if (!mesh.texcoords.empty()) {
    file << "\n";
    for (const auto& t : mesh.texcoords) {
      file << "vt " << t.x << " " << t.y << "\n";
    }
  }
  
  // Write faces (OBJ uses 1-based indexing)
  file << "\n";
  for (const auto& f : mesh.faces) {
    file << "f " << (f.x + 1) << " " << (f.y + 1) << " " << (f.z + 1) << "\n";
  }
  
  file.close();
  return true;
}

std::shared_ptr<SimplificationMesh> MeshIO::LoadMesh(const std::string& filepath) {
  auto mesh_result = MeshLoader::Import(filepath);
  
  if (mesh_result.vertex_obj == nullptr) {
    std::cerr << "Failed to load mesh: " << filepath << std::endl;
    return LoadOBJ(filepath);
  }
  
  // Convert to SimplificationMesh
  auto mesh = std::make_shared<SimplificationMesh>(
      SimplificationMesh::FromVertexObject(*mesh_result.vertex_obj));
  
  return mesh;
}

bool MeshIO::ParseVertex(const std::string& line, glm::vec3& vertex) {
  // TODO: Parse "v x y z"
  std::istringstream iss(line);
  std::string prefix;
  iss >> prefix >> vertex.x >> vertex.y >> vertex.z;
  return !iss.fail();
}

bool MeshIO::ParseNormal(const std::string& line, glm::vec3& normal) {
  // TODO: Parse "vn x y z"
  std::istringstream iss(line);
  std::string prefix;
  iss >> prefix >> normal.x >> normal.y >> normal.z;
  return !iss.fail();
}

bool MeshIO::ParseTexCoord(const std::string& line, glm::vec2& texcoord) {
  // TODO: Parse "vt u v"
  std::istringstream iss(line);
  std::string prefix;
  iss >> prefix >> texcoord.x >> texcoord.y;
  return !iss.fail();
}

bool MeshIO::ParseFace(const std::string& line, 
                        std::vector<glm::uvec3>& indices) {
  // TODO: Parse "f v1 v2 v3" or "f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3"
  // Handle triangulated faces and convert to triangles if needed
  
  std::istringstream iss(line);
  std::string prefix;
  iss >> prefix;
  
  std::vector<unsigned int> vertex_indices;
  std::string token;
  
  while (iss >> token) {
    // Parse vertex index (handle formats like "v", "v/vt", "v/vt/vn", "v//vn")
    size_t first_slash = token.find('/');
    std::string v_str = (first_slash != std::string::npos) 
                        ? token.substr(0, first_slash) 
                        : token;
    
    unsigned int v_idx = std::stoi(v_str) - 1;  // Convert to 0-based
    vertex_indices.push_back(v_idx);
  }
  
  // Triangulate if needed (simple fan triangulation)
  for (size_t i = 1; i + 1 < vertex_indices.size(); i++) {
    indices.push_back(glm::uvec3(
        vertex_indices[0],
        vertex_indices[i],
        vertex_indices[i + 1]
    ));
  }
  
  return !vertex_indices.empty();
}

}  // namespace GLOO

